# sms-service-db Repository Setup

Complete setup guide for the separate migration repository.

## Repository Structure

```
sms-service-db/
├── SmsService.Migrations.csproj
├── .gitignore
├── README.md
├── Migrations/                       # Auto-generated by EF
├── SmsService.Migrations.Tests/
│   ├── SmsService.Migrations.Tests.csproj
│   └── ModelSnapshotValidationTests.cs
└── .github/
    └── workflows/
        ├── validate-migrations.yml
        └── apply-migrations.yml
```

## Step 1: Create SmsService.Migrations.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <!-- Reference Domain from adjacent sms-service repo -->
  <ItemGroup>
    <ProjectReference Include="../sms-service/SmsService.Domain/SmsService.Domain.csproj" />
  </ItemGroup>

  <!-- EF Core Tools for migration generation -->
  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="10.0.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="10.0.2" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="10.0.2" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="10.0.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

</Project>
```

## Step 2: Create Design-Time DbContext Factory

Create `DesignTimeDbContextFactory.cs`:

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
using SmsService.Domain.Data;

namespace SmsService.Migrations;

/// <summary>
/// Design-time factory for EF Core tools to create DbContext during migrations
/// </summary>
public class DesignTimeDbContextFactory : IDesignTimeDbContextFactory<SmsDbContext>
{
    public SmsDbContext CreateDbContext(string[] args)
    {
        var optionsBuilder = new DbContextOptionsBuilder<SmsDbContext>();
        
        // Check if we should use in-memory database (for local testing)
        var useInMemory = Environment.GetEnvironmentVariable("USE_INMEMORY_DB")?.ToLower() == "true";
        
        if (useInMemory)
        {
            optionsBuilder.UseInMemoryDatabase("SmsServiceDb");
        }
        else
        {
            // Use SQL Server for actual migration generation
            var connectionString = Environment.GetEnvironmentVariable("SMS_CONNECTION_STRING") 
                ?? "Server=localhost,3433;Database=SmsService;User Id=sa;Password=DevPassword123!;TrustServerCertificate=true;";
            
            optionsBuilder.UseSqlServer(connectionString);
        }
        
        return new SmsDbContext(optionsBuilder.Options);
    }
}
```

## Step 3: Create Validation Test Project

Create `SmsService.Migrations.Tests/SmsService.Migrations.Tests.csproj`:

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.12.0" />
    <PackageReference Include="xunit" Version="2.9.2" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.8.2" />
    <PackageReference Include="FluentAssertions" Version="6.12.1" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="10.0.2" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="10.0.2" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="../SmsService.Migrations.csproj" />
    <ProjectReference Include="../../sms-service/SmsService.Domain/SmsService.Domain.csproj" />
  </ItemGroup>

</Project>
```

## Step 4: Create Model Validation Tests

Create `SmsService.Migrations.Tests/ModelSnapshotValidationTests.cs`:

```csharp
using Microsoft.EntityFrameworkCore;
using SmsService.Domain.Data;
using Xunit;
using FluentAssertions;

namespace SmsService.Migrations.Tests;

/// <summary>
/// Validates that Domain entities match the migration snapshot
/// </summary>
public class ModelSnapshotValidationTests
{
    [Fact]
    public void Domain_Entities_Should_Match_Migration_Snapshot()
    {
        // Arrange - Use in-memory database for testing
        var optionsBuilder = new DbContextOptionsBuilder<SmsDbContext>();
        optionsBuilder.UseInMemoryDatabase("TestDb");
        
        using var context = new SmsDbContext(optionsBuilder.Options);
        
        // Act - Get runtime model from Domain entities
        var model = context.Model;
        var entityTypes = model.GetEntityTypes().ToList();
        
        // Assert - Verify expected entities exist
        entityTypes.Should().NotBeEmpty("Domain should contain entities");
        
        var smsProviderEntity = entityTypes.FirstOrDefault(e => e.ClrType.Name == "SmsProvider");
        smsProviderEntity.Should().NotBeNull("SmsProvider entity should exist in model");
        
        // Verify table name
        smsProviderEntity!.GetTableName().Should().Be("SmsProviders");
        
        // Verify properties
        var properties = smsProviderEntity.GetProperties().Select(p => p.Name).ToList();
        properties.Should().Contain("Id");
        properties.Should().Contain("Name");
        properties.Should().Contain("IsActive");
        properties.Should().Contain("CreatedAt");
        
        // Verify Name property configuration
        var nameProperty = smsProviderEntity.FindProperty("Name");
        nameProperty.Should().NotBeNull();
        nameProperty!.GetMaxLength().Should().Be(50);
        nameProperty.IsNullable.Should().BeFalse();
        
        // Verify indexes
        var indexes = smsProviderEntity.GetIndexes().ToList();
        indexes.Should().NotBeEmpty("SmsProvider should have indexes");
        indexes.Should().Contain(i => i.Properties.Any(p => p.Name == "Name"), 
            "Should have unique index on Name");
    }
    
    [Fact]
    public void Migration_Snapshot_Should_Exist()
    {
        // Verify that migrations have been created
        var migrationsPath = Path.Combine(Directory.GetCurrentDirectory(), "..", "Migrations");
        
        if (Directory.Exists(migrationsPath))
        {
            var snapshotFile = Directory.GetFiles(migrationsPath, "*ModelSnapshot.cs").FirstOrDefault();
            snapshotFile.Should().NotBeNull(
                "Migration snapshot should exist. Run 'dotnet ef migrations add InitialCreate' to create it.");
        }
    }
}
```

## Step 5: GitHub Actions - Validate Migrations

Create `.github/workflows/validate-migrations.yml`:

```yaml
name: Validate Migrations

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

jobs:
  validate:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout sms-service-db repo
      uses: actions/checkout@v4
      with:
        path: sms-service-db
    
    - name: Sparse checkout Domain from sms-service
      uses: actions/checkout@v4
      with:
        repository: ripberge/sms-service
        sparse-checkout: |
          SmsService.Domain
        sparse-checkout-cone-mode: false
        path: sms-service
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '10.0.x'
    
    - name: Restore dependencies
      working-directory: sms-service-db
      run: dotnet restore
    
    - name: Build
      working-directory: sms-service-db
      run: dotnet build --no-restore
    
    - name: Run validation tests
      working-directory: sms-service-db
      run: dotnet test --no-build --verbosity normal
    
    - name: Check for uncommitted migrations
      working-directory: sms-service-db
      run: |
        if [ -n "$(git status --porcelain Migrations/)" ]; then
          echo "Error: Domain entities changed but migration not updated"
          echo "Run: dotnet ef migrations add <MigrationName>"
          exit 1
        fi
```

## Step 6: GitHub Actions - Apply Migrations

Create `.github/workflows/apply-migrations.yml`:

```yaml
name: Apply Migrations to Production

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - dev
          - staging
          - production

jobs:
  apply-migrations:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    
    steps:
    - name: Checkout sms-service-db repo
      uses: actions/checkout@v4
      with:
        path: sms-service-db
    
    - name: Sparse checkout Domain from sms-service
      uses: actions/checkout@v4
      with:
        repository: ripberge/sms-service
        sparse-checkout: |
          SmsService.Domain
        sparse-checkout-cone-mode: false
        path: sms-service
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '10.0.x'
    
    - name: Restore dependencies
      working-directory: sms-service-db
      run: dotnet restore
    
    - name: Build
      working-directory: sms-service-db
      run: dotnet build --no-restore
    
    - name: Generate SQL Script (for review)
      working-directory: sms-service-db
      run: |
        dotnet ef migrations script --idempotent --output migration.sql
        cat migration.sql
    
    # - name: Apply migrations
    #   working-directory: sms-service-db
    #   env:
    #     CONNECTION_STRING: ${{ secrets.AZURE_SQL_CONNECTION_STRING }}
    #   run: |
    #     dotnet ef database update --connection "$CONNECTION_STRING"
```

## Step 7: Create .gitignore

```
# Build results
[Dd]ebug/
[Rr]elease/
[Bb]in/
[Oo]bj/

# Visual Studio
.vs/
*.user
*.suo

# NuGet
*.nupkg

# Test results
TestResults/
coverage/
```

## Step 8: Create README.md

```markdown
# sms-service-db

Entity Framework migrations repository for SMS Service. This repository maintains database schema migrations separately from the application code.

## Architecture

This repository uses **sparse checkout** to pull only the `SmsService.Domain` project from the main [sms-service](https://github.com/ripberge/sms-service) repository. This allows:

- Domain entities to live in the application repo
- Migrations to be version-controlled separately
- Validation tests to ensure entities match migrations
- Independent deployment of schema changes

## Local Development Setup

### Prerequisites
- .NET 10 SDK
- Git
- SQL Server (only needed for generating actual migrations, not for testing)

### Initial Setup

1. **Clone this repo and sms-service adjacent to each other:**
   ```bash
   cd ~/code
   git clone https://github.com/ripberge/sms-service.git
   git clone https://github.com/ripberge/sms-service-db.git
   ```

2. **Restore packages:**
   ```bash
   cd sms-service-db
   dotnet restore
   ```

3. **Run validation tests (uses in-memory database):**
   ```bash
   dotnet test
   ```

4. **Set connection string (only for generating migrations):**
   ```bash
   export SMS_CONNECTION_STRING="Server=localhost,3433;Database=SmsService;User Id=sa;Password=DevPassword123!;TrustServerCertificate=true;"
   ```

### Generating Migrations

When Domain entities change in sms-service:

1. **Pull latest changes:**
   ```bash
   cd ../sms-service
   git pull
   cd ../sms-service-db
   ```

2. **Test with in-memory database first:**
   ```bash
   dotnet test
   ```

3. **Generate migration (uses SQL Server):**
   ```bash
   dotnet ef migrations add MigrationName
   ```

4. **Review generated files** in `Migrations/` folder

5. **Commit and push:**
   ```bash
   git add Migrations/
   git commit -m "feat: add migration for [description]"
   git push
   ```

### Running Tests

Validation tests use in-memory database and require no SQL Server:

```bash
dotnet test
```

### Applying Migrations Manually

```bash
dotnet ef database update --connection "your-connection-string"
```

## CI/CD Workflow

### Pull Request
1. Sparse checkout `SmsService.Domain` from sms-service
2. Run validation tests
3. Verify migration exists if Domain changed

### Production Deployment
1. Manual trigger via GitHub Actions
2. Generate SQL script for review
3. Apply migrations with approval gate

## Rollback Procedure

To rollback to a previous migration:

```bash
dotnet ef database update PreviousMigrationName --connection "connection-string"
```

**Note:** Always review the SQL script before applying to production.

## Merge Conflict Resolution

If `__ModelSnapshot.cs` has conflicts:

1. Pull latest from main: `git pull --rebase origin main`
2. Delete your migration file
3. Re-generate migration: `dotnet ef migrations add YourMigrationName`
4. Commit the new migration

## Troubleshooting

### "No project was found"
Ensure sms-service repo is cloned adjacent to sms-service-db.

### "Connection string not found" (when generating migrations)
Set the `SMS_CONNECTION_STRING` environment variable or use the default in `DesignTimeDbContextFactory.cs`.

### "Build failed"
Check that sms-service is up to date: `cd ../sms-service && git pull`

### Tests pass but migration generation fails
Tests use in-memory database. Migration generation requires SQL Server. Ensure SQL Server is running and connection string is set.
```

## Next Steps

1. **Clone sms-service-db locally** (if not already done):
   ```bash
   cd ~/Desktop/code
   git clone https://github.com/ripberge/sms-service-db.git
   ```

2. **Create all the files above** in sms-service-db repository

3. **Generate initial migration:**
   ```bash
   cd sms-service-db
   dotnet ef migrations add InitialCreate
   ```

4. **Commit and push to GitHub**

5. **Test the CI/CD workflow** by opening a PR
